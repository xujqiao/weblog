# libco协程概览

## 认识协程

> 号外，线程的英文是**thread**，其本意是针线，穿针引线的线。把**thread**翻译成**线程**，有机器翻译的感觉

协程，又叫用户级线程。「用户级」表示其生命周期在用户空间控制，不需要内核协助。「线程」表示它有自己的堆栈，是一个可以单独在cpu上执行的单元。协程的优势，显然不是名字后面的「线程」，而是前面的「用户级」。

线程，作为一个轻量级的进程，是程序的最小执行单元，其生命周期由内核控制，即用户态状态下无法感知其运行状态和控制其切换规则。导致在程序开发过程中，需要额外处理程序在执行的任意步骤被中断和恢复。同时，由于相同进程创建的线程共享本进程的命名空间和变量，导致在程序开发中，需要处理数据竞争和冲突。

上述线程的缺陷，在协程中均不存在。

首先，协程由用户态管理，运行状态和切换时机，均由用户感知。因此，可以在程序真正需要切换时再进行切换，如：rpc。
同时，同进程创建的协程虽然也共享本进程的命名空间和变量，可是同进程创建的协程，不会同时运行在不同的cpu，不存在竞争，大大减少开发线程增加的复杂度，达到以同步的方式编写代码，但性能比使用线程还要高的结果。
（注：go的协程可以同时运行在多个cpu）。

## libco的协程

基于上述的认知，一个协程的结构，应该包含以下内容：1️⃣可执行函数，2️⃣状态位，3️⃣私有内存空间，4️⃣管理协程的对象。
管理协程的结构应该包含以下内容：1️⃣等待队列，2️⃣ready队列，3️⃣超时管理，4️⃣当前运行的协程对象。

这是libco中协程的主要结构

```c++
struct stCoRoutine_t {
	stCoRoutineEnv_t *env; // 管理协程的对象

	pfn_co_routine_t pfn; // 可执行函数
	void *arg; // 参数

	// 私有内存空间
	coctx_t ctx;

	// 状态位
	char cStart;
	char cEnd;
	char cIsMain; //是否为主协程
	char cEnableSysHook;
	char cIsShareStack; // 是否开启共享栈模式
	...
};
```

`env`指向管理协程的对象，在libco中，运行在同一个线程上的各协程共享该结构
`pfn` `arg`是可执行函数和对应的入参，pfn_co_routine_t的结构是`typedef void* (*pfn_co_routine_t)(void*)`
`ctx`是私有内存空间，用于协程切换。切换的过程类似函数调用，函数调用期间要保存上下文，这样调用结束后能回到原函数的执行位置。这个私有空间就是存储协程切换的上下文，使得切换回来后，可以继续执行原协程的指令。
`cStart` `cEnd` `cIsMain`等等，均是标志位，标记本协程的状态。

## 协程如何切换

上述协程结构，除了`ctx`，其他成员都司空见惯，唯有负责切换的`ctx`需要花费时间琢磨。
协程切换，如同函数调用，即一个函数"主动地"调用另一个函数，既然本质是函数调用，研究清楚函数调用的原理，协程切换就能呼之欲出。

```c++
void func1() {
	int ret = func2(3, 5);
	return;
}

int func2(int a1, int a2) {
    return a1 + a2;
}
```

```as
func1:
        pushq   %rbp
        movq    %rsp, %rbp
        subq    $16, %rsp
        movl    $5, %esi  ; func2的第二个入参
        movl    $3, %edi  ; func2的第一个入参
        movl    $0, %eax
        call    func2  ; 调用func2
        movl    %eax, -4(%rbp)  ; 获得返回值
        nop
        leave
        ret
func2:
        pushq   %rbp ; 保存caller的基地址寄存器到栈
        movq    %rsp, %rbp ; 将当前栈地址寄存器保存到当前基地址寄存器
        movl    %edi, -4(%rbp) ; 将寄存器edi的值复制到栈空间-4(结合下面的指令，这里有点多余)
        movl    %esi, -8(%rbp) ; 将寄存器esi的值复制到栈空间-8
        movl    -4(%rbp), %edx ; 将栈空间-4复制到寄存器edx
        movl    -8(%rbp), %eax ; 将栈空间-8复制到寄存器eax
        addl    %edx, %eax ; 将寄存器edx值加eax并存入eax
        popq    %rbp ; 将原先caller的基地址寄存器复制到rbp
        ret
```

上面片段是函数`func1`调用`func2`的c++和汇编代码。在汇编代码里可以看出，在`func1`调用`func2`和`func2`执行`a1+a2`前后，均包含众多对寄存器和栈的操作，虽然在c++代码里仅一行`int ret = func2(3, 5)`，但在汇编层面，却有众多逻辑。

上述过程对寄存器和栈的操作，可以理解成**对caller上下文的保存和对callee的上下文恢复**。不过恢复callee的上下文后，执行的是callee函数的第一行，而不是特定的某一行，即，不是goto到callee的某一行。
那如何实现恢复callee上下文后能执行特定的某一行呢？很明显，是call屏蔽了这点。通过查看call的实现，发现控制下一条执行的指令是ip寄存器，即只需要修改callee上下文里的ip寄存器的地址为某一行，就能在恢复上下文后从指定行继续执行。

总结一下，函数调用涉及上下文，上下文是caller的寄存器和栈。同样的，协程切换也涉及上下文，上下文的内容也是寄存器和栈。

```c++
struct coctx_param_t {
	const void *s1;
	const void *s2;
};

struct coctx_t {
#if defined(__i386__)
	// 上下文
	void *regs[ 8 ];
#else
	void *regs[ 14 ];
#endif
	size_t ss_size;// 栈的大小
	char *ss_sp; // 栈顶指针esp
};
```

上述片段是libco中`coctx_t`的结构，可以看到，`regs`对应寄存器，`ss_size`和`ss_sp`对应栈。即，只要交换两个协程的`ctx`,即能实现两个协程的切换。
可以看出，协程的切换发生在用户态，切换期间涉及的数据量是轻量的，切换过程也是简单的。因此，实际业务中，协程的数量一般是万级别，相比于线程的百or千级别，协程的优势可想而知。


## 用户管理协程切换的好处

前面有提到，协程的切换可以在程序真正需要切换时再进行，如：rpc。
这样在需要cpu执行的时候让cpu执行，需要rpc时，让出cpu实现，切换到其他需要cpu执行的协程。如下图所示。

```
      +-------+---------------------+            
co1   | cpu   |      rpc            |            
      +-------+---------------------+            
              +------+--------------------+      
co2           | cpu  |   rpc              |      
              +------+--------------------+      
                     +------+-------------------+
co3                  | cpu  |   rpc             |
                     +------+-------------------+
                            .....                
```

------

CC BY-NC-SA 4.0

本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)进行许可。

本作品[xujqiao](https://github.com/xujqiao/weblog)博文, 由[xujqiao](https://github.com/xujqiao/weblog)创作，由[xujqiao](https://github.com/xujqiao/weblog)确认，转载请注明版权。
